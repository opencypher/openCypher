= CIP2016-12-16 - Constraints syntax
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Mats Rydberg <mats@neotechnology.com>

[abstract]
.Abstract
--
This CIP describes syntax and semantics for Cypher constraints.
These are language constructs that impose restrictions on the shape of the data graph, and how statements are allowed to change it.
--

toc::[]

== Motivation

Constraints provide utility for shaping the data graph.

== Background

Cypher has a loose notion of schema, in which nodes and relationships may take very heterogeneous forms, both in terms of properties and in graph patterns.
Constraints allows us to bound the heterogeneous nature of the property graph into a more regular form.

== Proposal

This CIP includes the following proposed constraints:

* <<uniqueness>>
* <<existence, Node property existence constraint>>
* <<existence, Relationship property existence constraint>>

Each constraint is detailed in its own below section.

Once a constraint has been created, it may not be amended.
Should a user wish to change its definition, it has to be dropped and recreated with an updated structure.

==== Constraint names

All constraints require the user to specify a nonempty _name_ at constraint creation time.
This name is subsequently the handle with which a user may refer to the constraint, e.g. when dropping it.

// TODO: Should we impose restrictions on the domain of constraint names, or are all Unicode characters allowed?

=== Syntax overview

The syntax for all constraints follow the same basic outline.

.Grammar definition for constraint syntax.
[source, ebnf]
----
constraint command = create-constraint | drop-constraint ;
create-constraint  = "CREATE", "CONSTRAINT", constraint-name, "FOR", constraint-pattern, "REQUIRE", constraint-expr ;
constraint-name    = symbolic-name
constraint-pattern = node-pattern | simple-pattern ;
constraint-expr    = uniqueness-constraint | existence-constraint ;
drop-constraint    = "DROP", "CONSTRAINT", constraint-name ;
----

The constraint expressions vary depending on the actual constraint (see the detailed sections).

.Example of dropping a constraint with name foo:
[source, cypher]
----
DROP CONSTRAINT foo
----

=== Semantics overview

The semantics are defined for each type of constraint, but some characteristics are shared:

* When a statement tries to create a constraint on a graph where the data does not pass the constraint criterion, that statement will raise an error.
* When a statement tries to create a constraint with a name that already exists, that statement will raise an error.
* When a statement tries to drop a constraint referencing a name that does not exist, that statement will raise an error.
* When an updating statement tries to modify the graph in such a way that it would violate a constraint, that statement will raise an error.

The constraints define a _domain_ within which the constraint applies.
The domain is defined by the constraint pattern.

[[uniqueness]]
=== Node property uniqueness constraint

This constraint enforces that there can not be duplicate values of a certain property for a certain type of node.
For example, that among nodes labeled with `:Person`, each `email` property must be unique.

==== Syntax

.Grammar definition for node property uniqueness constraint:
[source, ebnf]
----
uniqueness-constraint = "UNIQUE", property-expression, { ",", property-expression } ;
----

.Example of single-property uniqueness constraint:
[source, cypher]
----
CREATE CONSTRAINT unique_person_email
FOR (p:Person)
REQUIRE UNIQUE p.email
----

.Example of multiple-property uniqueness constraint:
[source, cypher]
----
CREATE CONSTRAINT unique_person_details
FOR (p:Person)
REQUIRE UNIQUE p.name, p.email, p.address
----

==== Semantics

The domain of a property uniqueness constraint is defined as all the nodes with a specific label where the specified property key(s) exist (are non-null).
When more than one property key is defined as part of the constraint, only nodes where _all_ of the properties exist are part of the domain.

The uniqueness mandates that two distinct nodes within the domain can not have the same combination of values for the defined properties (respectively).

===== Example

Consider the graph created by the following statement:

[source, cypher]
----
CREATE (:Color {name: 'white', rgb: 0xffffff})
CREATE (:Color {name: 'black', rgb: 0x000000})
CREATE (:Color {name: 'very, very dark grey', rgb: 0x000000}) // rounding error!
----

Due to the duplication of the `rgb` property, the following attempt at creating a constraint will fail:

[source, cypher]
----
CREATE CONSTRAINT only_one_color_per_rgb
FOR (c:Color)
REQUIRE UNIQUE c.rgb
----

Suppose that we would rather like to have one color node per name _and_ RGB value (to work around the rounding errors).
We could then use the following constraint, without modifying our data:

[source, cypher]
----
CREATE CONSTRAINT unique_color_nodes
FOR (c:Color)
REQUIRE UNIQUE c.rgb, c.name
----

[[existence]]
=== Property existence constraints

Property existence constraints are defined for both nodes and relationships, but the semantics are the same.
For this reason we will go over both constraints in the same section.

==== Syntax

.Grammar definition for property existence constraint:
[source, ebnf]
----
existence-constraint = "exists", "(", property-expression, ")" ;
----

.Example of node property existence constraint:
[source, cypher]
----
CREATE CONSTRAINT colors_must_have_rgb
FOR (c:Color)
REQUIRE exists(c.rgb)
----

.Example of relationship property existence constraint:
[source, cypher]
----
CREATE CONSTRAINT rates_have_quality
FOR ()-[l:RATED]-()
REQUIRE exists(l.rating)
----

==== Semantics

The domain of a node property existence constraint are all nodes with the specified label.
Similarly, the domain of a relationship property existence constraint are all relationship with the specified type.

Property existence constraints mandates that the value of the specified property exists (is non-null) for all entities in the domain.

===== Example

Consider the graph containing `:Color` nodes.
Each color has an integral RGB value representation in a property `rgb`.
Users may lookup color nodes to extract their RGB values for application processing.
Users may also add new color nodes to the graph.

Suppose the query that looks up the RGB value of a color with a given name looks like this:

[source, cypher]
----
MATCH (c:Color {name: $name})
WHERE exists(c.rgb)
RETURN c.rgb
----

The `WHERE` clause protects the application from receiving `null` values back for user-defined colors where the RGB values have not been specified correctly.
It may however be eliminated by the introduction of a node property existence constraint:

[source, cypher]
----
CREATE CONSTRAINT colors_must_have_rgb
FOR (c:Color)
REQUIRE exists(c.rgb)
----

Any updating statement that would create a `:Color` node without specifying a `rgb` property for it would now fail.

=== Interaction with existing features

The main interaction between the constraints and the rest of the language happens during updating statements.
Existing constraints will cause certain updating statements to fail; in fact, that's the main purpose.

=== Alternatives

Plenty of alternative syntaxes have been discussed:

* `GIVEN`, `CONSTRAIN`, `ASSERT` instead of `FOR`
* `ASSERT`, `ENFORCE`, `IMPLIES` instead of `REQUIRE`

The use of existing expression to express uniqueness, instead of using a new keyword `UNIQUE`, on the form:
----
FOR (p:Person), (q:Person)
REQUIRE p.email <> q.email AND p <> q
----
which quickly becomes unwieldy for multiple properties.

== What others do

In SQL, the following constraints exist (http://www.w3schools.com/sql/sql_constraints.asp):

* `NOT NULL` - Indicates that a column cannot store NULL value
* `UNIQUE` - Ensures that each row for a column must have a unique value
* `PRIMARY KEY` - A combination of a `NOT NULL` and `UNIQUE`. Ensures that a column (or combination of two or more columns) have a unique identity which helps to find a particular record in a table more easily and quickly
* `FOREIGN KEY` - Ensure the referential integrity of the data in one table to match values in another table
* `CHECK` - Ensures that the value in a column meets a specific condition
* `DEFAULT` - Specifies a default value for a column
The next chapters will describe each constraint in detail.

The property existence constraints represent the same functionality as the `NOT NULL` SQL constraint.
The node property uniqueness constraint represents the `PRIMARY KEY` SQL constraint.

SQL constraints may be introduced at table creation time (in a `CREATE TABLE` statement), or in an `ALTER TABLE` statement:

.Creating a persons table in SQL Server / Oracle / MS Access:
[source, sql]
----
CREATE TABLE Persons
(
   P_Id int NOT NULL UNIQUE,
   LastName varchar(255) NOT NULL,
   FirstName varchar(255))
----

.Creating a persons table in MySQL:
[source, sql]
----
CREATE TABLE Persons
(
  P_Id int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255)
  UNIQUE (P_Id)
)
----

.Adding a named composite `UNIQUE` constraint in MySQL / SQL Server / Oracle / MS Access:
[source, sql]
----
ALTER TABLE Persons
ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)
----

== Benefits to this proposal

Constraints make Cypher's notion of schema more well-defined, and allows users to keep graphs in a more regular, easier to manage form.

== Caveats to this proposal

For an implementing system, some constraints may prove challenging to enforce, as they generally require scanning through large parts of the graph to look for conflicting entities.
