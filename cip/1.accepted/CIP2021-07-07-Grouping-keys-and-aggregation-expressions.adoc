= CIP2021-07-07 Grouping key and aggregation expressions
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Andrés Taylor <andres@neotechnology.com>, Hannes Voigt <hannes.voigt@neo4j.com>


[abstract]
.Abstract
--

--

toc::[]

== Background

=== Problem

In this CIP we assume the following baseline semantics as a given and well-defined.

We also assume following driving table in examples:

.Example driving table
|===
|a|b|c

|1|2|3
|1|3|4
|2|3|5
|===

==== Baseline aggregation

Cypher allows grouping and aggregating (form here on just referred to as _aggregation_) the driving table in the WITH and in the RETURN clause.

Formally, the aggregation of a driving table _D_ can be described formally as
pass:q[γ<sub>_K_, _A_</sub>(_D_)] where

* _K_ is a (possibly empty) set of pairs (_k_, _al_) where
** _k_ is a variable -- called a _grouping key_ -- in the driving table _D_,
** _al_ is variable name -- also called an _alias_ -- that different from all other aliases _x_ with (·, _x_) ∈ _K_., and
* _A_ is a non-empty set of triple (_agg_, _x_, _al_) where
** _agg_ is an aggregation function and
** _x_ is a variable in the driving table _D_
** _al_ is variable name -- also called an _alias_ -- that different from all other aliases _x_ with (·, ·, _x_) ∈ _A_ or _x_ with (·, _x_) ∈ _K_.

Assuming _K_ = {(_k_~1~, _ka_~1~), (_k_~2~, _ka_~1~), ..., (_k~N~_, _ka~N~_)} and _A_ = {(_agg_~1~, _x_~1~, _al_~1~), (_agg_~2~, _x_~2~, _al_~2~), ..., (_agg~M~_, _x~M~_, _al~M~_)}, the Cypher equivalent of pass:q[γ<sub>_K_, _A_</sub>(_D_)] is

[source, cypher, subs="quotes"]
----
WITH _k_~1~ AS _ka_~1~, _k_~2~ AS _ka_~2~, ..., _k~N~_ AS _ka~N~_,
     _agg_~1~(_x_~1~) AS _al_~1~, _agg_~2~(_x_~2~) AS _al_~2~, ..., _agg~M~_(_x~M~_) AS _al~M~_
----

and

[source, cypher, subs="quotes"]
----
RETURN _k_~1~ AS _k_~1~, _k_~2~ AS _k_~2~, ..., _k~N~_ AS _k~N~_,
       _agg_~1~(_x_~1~) AS _al_~1~, _agg_~2~(_x_~2~) AS _al_~2~, ..., _agg~M~_(_x~M~_) AS _al~M~_
----

Accordingly

.[[Q1]]Q1
[source, cypher]
----
RETURN a AS a, SUM(c) AS sumC
----

Grouped the driving table by `a` and computes the sum of all `c` as `sumC` for each group, so that result is:

.Result Q1
|===
|a|sumC

|1|7
|2|5
|===

==== Baseline projection

The WITH and the RETURN clause also allow projecting the driving table including the computation of new columns (in database theory, this is called extended projection).

The projection of a driving table _D_ can be described formally as π__~P~__(_D_) where

* _P_ is a nonempty set of pairs (_ex_, _al_) where
** _ex_ is a tree of operations of the expression sub-language where each of the leaves is either
*** a constant (such as a value literal or a label),
*** a parameter, or
*** a variable in the driving table _D_; and
** _al_ is an _alias_ that different from all other aliases _x_ with (·, _x_) ∈ _P_.

Assuming _P_ = {(_ex_~1~, _al_~1~), (_ex_~2~, _al_~2~), ..., (_ex~N~_, _al~N~_)}, the Cypher equivalent of π__~P~__(_D_) is

[source, cypher, subs="quotes"]
----
WITH _ex_~1~ AS _al_~1~, _ex_~2~ AS _al_~2~, ..., _ex~N~_ AS _al~N~_
----

and

[source, cypher, subs="quotes"]
----
RETURN _ex_~1~ AS _al_~1~, _ex_~2~ AS _al_~2~, ..., _ex~N~_ AS _al~N~_
----

Accordingly, the RETURN clause

.[[Q2]]Q2
[source, cypher]
----
RETURN b-a AS x, b*c AS y
----

projects each row in the driving table to `b` minus `a` (as `x`) and the product of `b` and `c` (as `y`), so that result is:

.Result Q2
|===
|x|y

|1|6
|2|12
|1|15
|===

The WITH and the RETURN clauses also allow ordering and truncating the driving table, but let's ignore these aspects in this CIP.

==== Beyond baseline semantics -- simple rewrite semantics

Cypher's WITH and the RETURN are syntactically more flexible when the two baseline semantics. In particular, they allow mixing aggregation and projection rather freely.
Specifically, the WITH and the RETURN clause denoted the parameters for projection (_P_) and aggregation (_K_ and _A_) with a single nonempty set _L_ of https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ProjectionItem[<ProjectionItem>]s `_ex_ AS _al_` where

* _ex_ is an expression that is allowed to contain aggregation functions and
* _al_ is an alias.

For instance, the RETURN clause

.[[Q3]]Q3
[source, cypher]
----
RETURN b-a AS x, SUM(b*c) AS sumBC
----

should produce a result that is grouped by `b` minus `a` (as `x`) and the sum of all products of `b` and `c` should be computed as `sumBC` for each group, so that result is:

.Result Q3
|===
|x|sumBC

|1|21
|2|12
|===

The semantics of such an RETURN (and WITH) clause can be described as a rewrite to the two baseline semantics combined by Cypher's linear composition.

For this purpose, the <ProjectionItem>s in _L_ can be spilt into _aggregates_ and _grouping keys_:

* A <ProjectionItem> _p_ is an aggregate if it is of the form `_agg_(_ex_) AS _al_`, where
** _agg_ is an aggregation function,
** _ex_ is a valid expression, and
** _al_ is an alias; and
* A <ProjectionItem> _p_ is a grouping key if is not an aggregate

Hence, for a <ProjectionItem> _p_

* If _p_ is of the form `_ex_ AS _al_`
** Let `PROJ(_p_)` be `_ex_ AS _al_` and
** Let `AGGR(_p_)` be `_al_ AS _al_`
* If _p_ is of the form `_agg_(_ex_) AS _al_`
** Let `PROJ(_p_)` be `_x_ AS _al_` and
** Let `AGGR(_p_)` be `_agg_(_al_) AS _al_`

Further, for a set of <ProjectionItem>s _L_ = {_p_~1~, _p_~2~, ... _p~N~_},

* Let `PROJ(_L_)` be `PROJ(_p_~1~), PROJ(_p_~2~), ..., PROJ(_p~N~_)` and
* Let `AGGR(_L_)` be `AGGR(_p_~1~), AGGR(_p_~2~), ..., AGGR(_p~N~_)`

With this the semantics of `RETURN _L_` can be defined as effectively equivalent to

[source, cypher, subs="quotes"]
----
WITH PROJ(_L_)
RETURN AGGR(_L_)
----

Analogously, the semantics of `WITH _L_` can be defined as effectively equivalent to

[source, cypher, subs="quotes"]
----
WITH PROJ(_L_)
WITH AGGR(_L_)
----

For instance, <<Q3>> from above (`RETURN b-a AS x, SUM(b*c) AS sumBC`) can be defined as effectively equivalent to

[source, cypher]
----
WITH b-a AS x, b*c AS sumBC
RETURN x AS x, SUM(sumBC) AS sumBC
----

Let's call this the _simple rewrite semantics_ for the WITH and RETURN clause.

==== Beyond simple rewrite semantics

While this solution works nicely for the considered examples, it is limited.
Specifically, it only supports aggregation function in expressions of the form `_agg_(_ex_)`.

Cypher, however, also allows aggregation functions in expressions of the form, such as

* `_ex_~1~ + _agg_(_ex_~2~)`
* `_agg_(_ex_~1~) + _ex_~2~`
* `_agg_~1~(_ex_~1~) + _ex~2~_ * _agg_~2~(_ex_~3~)`

However, such expressions may still be sensible and useful.

Consider the RETURN clause

.[[Q4]]Q4
[source, cypher]
----
RETURN a AS a, (a + SUM(b*c) - MIN(c)) * 2 AS agg
----

should produce a result that is grouped by `a` and `agg` should be computed for each group as the sum of all products of `b` and `c` added to the value `a` and multiplied by two, so that result would be:

.Result Q4
|===
|a|agg

|1|32
//(1 + (2*3 + 3*4) - 3) * 2
|2|24
//(2 + (3*5) - 5) * 2
|===

It has been documented on multiple occasions (e.g. cf. http://opencypher.org/articles/2017/07/27/ocig1-aggregations-article/[First oCIG Meeting]) the existing semantics or Cypher is imprecise on such queries.

This proposal provides a precise semantics.

== Proposal

=== Syntax

_None. -- This proposal does not propose and net-new syntax._

=== Semantics

For a <ProjectionItem> _p_ = `_postEx_ AS _al_`, let _AGG_(_p_) be the set of (sub-)expressions _aggex_ of the form _agg_(_preEx_).

The set of <ProjectionItem>s _L_ is split according to _AGG_(_p_) in two cases

* <ProjectionItem>s _p_ in _L_ where _AGG_(_p_) is non-empty
* <ProjectionItem>s _p_ in _L_ where _AGG_(_p_) is empty

Hence, for a <ProjectionItem> _p_ = `_ex_ AS _al_`,

* If _AGG_(_p_) = ∅
** Let `PRE_PROJ(_p_)` be `_ex_ AS _al_`,
** Let `AGGR(_p_)` be `_al_ AS _al_`, and
** Let `POST_PROJ(_p_)` be `_al_ AS _al_`
* If _AGG_(_p_) = {`_agg_~1~(_preEx_~1~)`, `_agg_~2~(_preEx_~2~)`, ..., `_aggN_(_preEx_~N~)`} with _N_ > 0
** Let `PRE_PROJ(_p_)` be `_preEx_~1~ AS _al_+++_+++1, _preEx_~2~ AS _al_+++_+++2, ..., _preEx~N~_ AS _al_+++_+++_N_`,
** Let `AGGR(_p_)` be `_agg_~1~(_al_+++_+++1) AS _al_+++_+++1, _agg_~2~(_al_+++_+++2) AS _al_+++_+++2, ..., _agg~N~_(_al_+++_+++_N_ AS _al_+++_+++_N_`, and
** Let `POST_PROJ(_p_)` be `_postEx_ AS _al_` where _postEx_ is _ex_ with each `_agg~i~_(_preEx~i~_)` in _AGG_(_p_) being replaced by `_al_+++_+++_i_` for 1 ≤ _i_ ≤ _N_.

Further, for a set of <ProjectionItem>s _L_ = {_p_~1~, _p_~2~, ... _p~N~_},

* Let `PRE_PROJ(_L_)` be `PRE_PROJ(_p_~1~), PRE_PROJ(_p_~2~), ..., PRE_PROJ(_p~N~_)`,
* Let `AGGR(_L_)` be `AGGR(_p_~1~), AGGR(_p_~2~), ..., AGGR(_p~N~_)`, and
* Let `POST_PROJ(_L_)` be `POST_PROJ(_p_~1~), POST_PROJ(_p_~2~), ..., POST_PROJ(_p~N~_)`.

With this the semantics of `RETURN _L_` can be defined as effectively equivalent to

[source, cypher, subs="quotes"]
----
WITH PRE_PROJ(_L_)
WITH AGGR(_L_)
RETURN POST_PROJ(_L_)
----

Analogously, the semantics of `WITH _L_` can be defined as effectively equivalent to

[source, cypher, subs="quotes"]
----
WITH PRE_PROJ(_L_)
WITH AGGR(_L_)
WITH POST_PROJ(_L_)
----

For instance, <<Q4>> from above (`RETURN a AS a, (a + SUM(b*c) - MIN(c)) * 2 AS agg`) can be defined as effectively equivalent to

[source, cypher]
----
WITH a AS a, b*c AS agg_1, c AS agg_2
WITH a AS a, SUM(agg_1) AS agg_1, MIN(agg_2) AS agg_2
RETURN a AS a, (a + agg_1 - agg_2) * 2 AS agg
----

// TODO syntactic restriction implied by this semantics

=== Examples


== What others do


== Benefits to this proposal


== Caveats to this proposal

