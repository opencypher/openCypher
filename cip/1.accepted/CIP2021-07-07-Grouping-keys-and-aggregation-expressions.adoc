= CIP2021-07-07 Grouping key and aggregation expressions
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Andrés Taylor <andres@neotechnology.com>, Hannes Voigt <hannes.voigt@neo4j.com>


[abstract]
.Abstract
--

--

toc::[]

== Background

=== Problem

In this CIP we assume the following baseline semantics as a given and well-defined.

We also assume following driving table in examples:

.Example driving table
|===
|a|b|c

|1|2|3
|1|3|4
|2|3|5
|===

==== Baseline aggregation

Cypher allows grouping and aggregating (form here on just referred to as _aggregation_) the driving table in the WITH and in the RETURN clause.

Formally, the aggregation of a driving table _D_ can be described formally as
pass:q[γ<sub>_K_, _A_</sub>(_D_)] where

* _K_ is a (possibly empty) set of pairs (_k_, _al_) where
** _k_ is a variable -- called a _grouping key_ -- in the driving table _D_,
** _al_ is variable name -- also called an _alias_ -- that different from all other aliases _x_ with (·, _x_) ∈ _K_., and
* _A_ is a non-empty set of triple (_agg_, _x_, _al_) where
** _agg_ is an aggregation function and
** _x_ is a variable in the driving table _D_
** _al_ is variable name -- also called an _alias_ -- that different from all other aliases _x_ with (·, ·, _x_) ∈ _A_ or _x_ with (·, _x_) ∈ _K_.

Assuming _K_ = {(_k_~1~, _ka_~1~), (_k_~2~, _ka_~1~), ..., (_k~N~_, _ka~N~_)} and _A_ = {(_agg_~1~, _x_~1~, _al_~1~), (_agg_~2~, _x_~2~, _al_~2~), ..., (_agg~M~_, _x~M~_, _al~M~_)}, the Cypher equivalent of pass:q[γ<sub>_K_, _A_</sub>(_D_)] is

[source, cypher, subs="quotes"]
----
WITH _k_~1~ AS _ka_~1~, _k_~2~ AS _ka_~2~, ..., _k~N~_ AS _ka~N~_,
     _agg_~1~(_x_~1~) AS _al_~1~, _agg_~2~(_x_~2~) AS _al_~2~, ..., _agg~M~_(_x~M~_) AS _al~M~_
----

and

[source, cypher, subs="quotes"]
----
RETURN _k_~1~ AS _k_~1~, _k_~2~ AS _k_~2~, ..., _k~N~_ AS _k~N~_,
       _agg_~1~(_x_~1~) AS _al_~1~, _agg_~2~(_x_~2~) AS _al_~2~, ..., _agg~M~_(_x~M~_) AS _al~M~_
----

.Baseline aggregation
====

.[[Q1]]Q1
[source, cypher]
----
RETURN a AS a, SUM(c) AS sumC
----

Grouped the driving table by `a` and computes the sum of all `c` as `sumC` for each group, so that result is:

.Result Q1
|===
|a|sumC

|1|7
|2|5
|===
====

==== Baseline projection

The WITH and the RETURN clause also allow projecting the driving table including the computation of new columns (in database theory, this is called extended projection).

The projection of a driving table _D_ can be described formally as π__~P~__(_D_) where

* _P_ is a nonempty set of pairs (_ex_, _al_) where
** _ex_ is a tree of operations of the expression sub-language where each of the leaves is either
*** a constant (such as a value literal or a label),
*** a parameter, or
*** a variable in the driving table _D_; and
** _al_ is an _alias_ that different from all other aliases _x_ with (·, _x_) ∈ _P_.

Assuming _P_ = {(_ex_~1~, _al_~1~), (_ex_~2~, _al_~2~), ..., (_ex~N~_, _al~N~_)}, the Cypher equivalent of π__~P~__(_D_) is

[source, cypher, subs="quotes"]
----
WITH _ex_~1~ AS _al_~1~, _ex_~2~ AS _al_~2~, ..., _ex~N~_ AS _al~N~_
----

and

[source, cypher, subs="quotes"]
----
RETURN _ex_~1~ AS _al_~1~, _ex_~2~ AS _al_~2~, ..., _ex~N~_ AS _al~N~_
----

.Baseline projection
====
The RETURN clause

.[[Q2]]Q2
[source, cypher]
----
RETURN b-a AS x, b*c AS y
----

projects each row in the driving table to `b` minus `a` (as `x`) and the product of `b` and `c` (as `y`), so that result is:

.Result Q2
|===
|x|y

|1|6
|2|12
|1|15
|===
====

The WITH and the RETURN clauses also allow ordering and truncating the driving table, but let's ignore these aspects in this CIP.

==== Beyond baseline semantics -- simple rewrite semantics[[simpleRewrite]]

Cypher's WITH and the RETURN are syntactically more flexible when the two baseline semantics.
In particular, they allow mixing aggregation and projection rather freely.
Specifically, the WITH and the RETURN clause denoted the parameters for projection (_P_) and aggregation (_K_ and _A_) with a single nonempty set _L_ of https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ProjectionItem[<ProjectionItem>]s `_ex_ AS _al_` where

* _ex_ is an expression that is allowed to contain aggregation functions and
* _al_ is an alias.

.Mixing aggregation and projection
====
The RETURN clause

.[[Q3]]Q3
[source, cypher]
----
RETURN b-a AS x, SUM(b*c) AS sumBC
----

should produce a result that is grouped by `b` minus `a` (as `x`) and the sum of all products of `b` and `c` should be computed as `sumBC` for each group, so that result is:

.Result Q3
|===
|x|sumBC

|1|21
|2|12
|===
====

The semantics of such an RETURN (and WITH) clause can be described as a rewrite to the two baseline semantics combined by Cypher's linear composition.

For this purpose, the <ProjectionItem>s in _L_ can be spilt into _aggregates_ and _grouping keys_:

* A <ProjectionItem> _p_ is an aggregate if it is of the form `_agg_(_ex_) AS _al_`, where
** _agg_ is an aggregation function,
** _ex_ is a valid expression, and
** _al_ is an alias; and
* A <ProjectionItem> _p_ is a grouping key if is not an aggregate

Hence, for a <ProjectionItem> _p_

* If _p_ is of the form `_ex_ AS _al_`
** Let `PROJ(_p_)` be `_ex_ AS _al_` and
** Let `AGGR(_p_)` be `_al_ AS _al_`
* If _p_ is of the form `_agg_(_ex_) AS _al_`
** Let `PROJ(_p_)` be `_x_ AS _al_` and
** Let `AGGR(_p_)` be `_agg_(_al_) AS _al_`

Further, for a set of <ProjectionItem>s _L_ = {_p_~1~, _p_~2~, ... _p~N~_},

* Let `PROJ(_L_)` be `PROJ(_p_~1~), PROJ(_p_~2~), ..., PROJ(_p~N~_)` and
* Let `AGGR(_L_)` be `AGGR(_p_~1~), AGGR(_p_~2~), ..., AGGR(_p~N~_)`

With this the semantics of `RETURN _L_` can be defined as effectively equivalent to

[source, cypher, subs="quotes"]
----
WITH PROJ(_L_)
RETURN AGGR(_L_)
----

Analogously, the semantics of `WITH _L_` can be defined as effectively equivalent to

[source, cypher, subs="quotes"]
----
WITH PROJ(_L_)
WITH AGGR(_L_)
----

.Simple rewrite semantics
====
With this semantics, the RETURN clause in <<Q3>>

[source, cypher]
----
RETURN b-a AS x, SUM(b*c) AS sumBC`)
----

is defined as effectively equivalent to

[source, cypher]
----
WITH b-a AS x, b*c AS sumBC
RETURN x AS x, SUM(sumBC) AS sumBC
----
====

Let's call this the _simple rewrite semantics_ for the WITH and RETURN clause.

==== Beyond simple rewrite semantics

While this solution works nicely for the considered examples, it is limited.
Specifically, it only supports aggregation function in expressions of the form `_agg_(_ex_)`.

Cypher, however, also allows aggregation functions to appear as sub-expression of <ProjectionItem>s, i.e. Cypher allows <ProjectionItem>s with expressions of forms, such as

* `_ex_~1~ + _agg_(_ex_~2~)`
* `_agg_(_ex_~1~) + _ex_~2~`
* `_agg_~1~(_ex_~1~) + _ex~2~_ * _agg_~2~(_ex_~3~)`

Such expressions can still be sensible and useful.

.Aggregation functions a sub-expressions
====
The RETURN clause

.[[Q4]]Q4
[source, cypher]
----
RETURN a AS a, (a + SUM(b*c) - MIN(c)) * 2 AS foo
----

should produce a result that is grouped by `a` and `foo` should be computed for each group as the sum of all products of `b` and `c` added to the value `a` and multiplied by two, so that result would be:

.Result Q4
|===
|a|foo

|1|32
//(1 + (2*3 + 3*4) - 3) * 2
|2|24
//(2 + (3*5) - 5) * 2
|===
====

[NOTE]
====
A less artificial example is calculating the total gross of an order as the discounted sum of line item net values (product price multiplied by amount) in query such as:

.[[Q5]]Q5
[source, cypher]
----
MATCH
(c:Customer)-[:LOCATED_IN]->(s:State)
(c)-[:ORDERED]->(o:Order)
(o)-[:INCLUDES]->(li:LineItem)-->(p:Product)
RETURN s AS state, c AS customer, o AS order,
       SUM(li.amount * p.price) * c.discount * j.vat AS totalGross
----
====

It has been documented on multiple occasions (e.g. cf. http://opencypher.org/articles/2017/07/27/ocig1-aggregations-article/[First oCIG Meeting]) the existing semantics or Cypher is imprecise on such queries.

A precise semantics on such queries has to provide

* A clear definition which <ProjectionItem>s constitute the grouping keys
* Clear rules for which sub-expressions are allowed in <ProjectionItem>s containing aggregation functions

This proposal provides a such precise semantics.

== Proposal

=== Syntax

_None. -- This proposal does not propose and net-new syntax._

=== Semantics

The proposed semantics defined as a rewrite to the baseline semantics (similar to <<simpleRewrite,simple rewrite semantics>> discussed above).
The proposed semantics does not cover all queries and hence implies a syntax restriction to rule out queries that are not covered.
We discuss the rewrite and the syntax restriction in the follow two subsections.

==== Rewrite

For a <ProjectionItem> _p_ = `_postEx_ AS _al_`, let _AGG_(_p_) be the set of (sub-)expressions _aggex_ of the form _agg_(_preEx_).

The set of <ProjectionItem>s _L_ is split according to _AGG_(_p_) in two cases

* <ProjectionItem>s _p_ in _L_ where _AGG_(_p_) is non-empty
* <ProjectionItem>s _p_ in _L_ where _AGG_(_p_) is empty

Hence, for a <ProjectionItem> _p_ = `_ex_ AS _al_`,

* If _AGG_(_p_) = ∅
** Let `PRE_PROJ(_p_)` be `_ex_ AS _al_`,
** Let `AGGR(_p_)` be `_al_ AS _al_`, and
** Let `POST_PROJ(_p_)` be `_al_ AS _al_`
* If _AGG_(_p_) = {`_agg_~1~(_preEx_~1~)`, `_agg_~2~(_preEx_~2~)`, ..., `_aggN_(_preEx_~N~)`} with _N_ > 0
** Let `PRE_PROJ(_p_)` be `_preEx_~1~ AS _al_+++_+++1, _preEx_~2~ AS _al_+++_+++2, ..., _preEx~N~_ AS _al_+++_+++_N_`,
** Let `AGGR(_p_)` be `_agg_~1~(_al_+++_+++1) AS _al_+++_+++1, _agg_~2~(_al_+++_+++2) AS _al_+++_+++2, ..., _agg~N~_(_al_+++_+++_N_ AS _al_+++_+++_N_`, and
** Let `POST_PROJ(_p_)` be `_postEx_ AS _al_` where _postEx_ is _ex_ with each `_agg~i~_(_preEx~i~_)` in _AGG_(_p_) being replaced by `_al_+++_+++_i_` for 1 ≤ _i_ ≤ _N_.

Further, for a set of <ProjectionItem>s _L_ = {_p_~1~, _p_~2~, ... _p~N~_},

* Let `PRE_PROJ(_L_)` be `PRE_PROJ(_p_~1~), PRE_PROJ(_p_~2~), ..., PRE_PROJ(_p~N~_)`,
* Let `AGGR(_L_)` be `AGGR(_p_~1~), AGGR(_p_~2~), ..., AGGR(_p~N~_)`, and
* Let `POST_PROJ(_L_)` be `POST_PROJ(_p_~1~), POST_PROJ(_p_~2~), ..., POST_PROJ(_p~N~_)`.

With this the semantics of `RETURN _L_` can be defined as effectively equivalent to

[source, cypher, subs="quotes"]
----
WITH PRE_PROJ(_L_)
WITH AGGR(_L_)
RETURN POST_PROJ(_L_)
----

Analogously, the semantics of `WITH _L_` can be defined as effectively equivalent to

[source, cypher, subs="quotes"]
----
WITH PRE_PROJ(_L_)
WITH AGGR(_L_)
WITH POST_PROJ(_L_)
----

.Rewrite semantics
====
With this semantics, the RETURN clause in <<Q4>>

[source, cypher]
----
RETURN a AS a, (a + SUM(b*c) - MIN(c)) * 2 AS agg
----

is defined as effectively equivalent to

[source, cypher]
----
WITH a AS a, b*c AS foo_1, c AS foo_2
WITH a AS a, SUM(foo_1) AS foo_1, MIN(foo_2) AS foo_2
RETURN a AS a, (a + foo_1 - foo_2) * 2 AS foo
----
====

Note that the semantics proposed here also provides for the mixing of projection and aggregation that the <<simpleRewrite,simple rewrite semantics>> covers, i.e. it is a generalization of the simple rewrite semantics.

.Rewrite semantics on simple mixing of projection and aggregation
====
The RETURN clause in <<Q3>>

[source, cypher]
----
RETURN b-a AS x, SUM(b*c) AS sumBC
----

is defined as effectively equivalent to

[source, cypher]
----
WITH b-a AS x, b*c AS sumBC_1
WITH x AS x, SUM(sumBC_1) AS sumBC_1
RETURN x AS x, sumBC_1 AS sumBC
----
====

==== Syntax restriction

The rewrite does not cover all syntactically possible queries.

.Aggregation *not* covered by the rewrite
====

By the proposed semantics, the RETURN clause

.[[Q6]]Q6
[source, cypher]
----
RETURN a AS a, b + SUM(c) * 2 AS foo
----

is defined as effectively equivalent to

[source, cypher]
----
WITH a AS a, c AS foo_1
WITH a AS a, SUM(foo_1) AS foo_1
RETURN a AS a, b + foo_1 * 2 AS foo
----

Note that variable `b` appears in the <ProjectionItem> `b + foo_1 * 2 AS foo` in the RETURN clause.
However, variable `b` has already by removed from the driving table by the previous projections.
In other words, the proposed rewrite produce invalid query text for <<Q6>>.
====



// TODO syntactic restriction implied by this semantics
// - as in https://trello-attachments.s3.amazonaws.com/5b484b125e3c6d756d136739/5ff70a2eb9fa9c57a9dbdc1e/dd4878f225c6facb6e40d700a3bbde7b/Implementation_report.pdf
// -> The non-aggregating sub-expressions of an expression that contains an aggregation MUST be garanteed to be constant under the grouping key.
// An implementation expected to detect by any of following situation
// - The whole sub-expression is part of the explicitly projected grouping key (under left-associative parsing)
// - Each operand in the sub-expression is either:
//   - Part of the grouping key from being projected explicitly
//   - A constant
//   - A parameter


=== Examples


== What others do


== Benefits to this proposal


== Caveats to this proposal

