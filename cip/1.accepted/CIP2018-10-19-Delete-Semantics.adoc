= CIP2018-10-19 Semantics of Deleted Elements
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Tobias Lindaaker <tobias.lindaaker@neotechnology.com>, Mats Rydberg <mats@neo4j.org>

[abstract]
.Abstract
--
This is a high-level summary of the aim and description of the CIP.
--

toc::[]


== Motivation

Cypher allows reading clauses to occur after updating clauses.
This includes reading clauses after clauses that delete elements.
Since the driving table of the preceding query (parts) is retained into the succeeding reading query (parts), this means that entries in the driving table that previously contained elements might now contain elements that have been deleted.

The semantics of such deleted elements are not obvious.
In fact, implementations have dealt with these in inconsistent ways, sometimes allowing access to the element id, or its properties, or allowing `MATCH` clauses to find deleted elements, and sometimes none of those things.
The need for consistent semantics for such deleted elements is expressed in part by `CIR-2017-263`.
This CIP specifies consistent and clear semantics for such deleted elements.


== Proposal

This CIP specifies that the semantics of accessing deleted elements is the same as accessing `NULL` values.
This can be thought of as replacing all occurrences of the deleted elements (anywhere) in the driving table (including in nested values) with `NULL`, or as treating the deleted elements as _effectively_ `NULL`.

`CIP-2015-10-27` defines that visibility between clauses follow a linear model.
That is, the effects of a clause are visible to the clause itself and all subsequent clauses, but never to a preceding clause.
That applies also to deleted elements.
These semantics effect the `DELETE` clause itself, even if not succeeded by further reading clauses, since the same element can occur in multiple rows in the driving table.

These semantics are consistent with the `OPTIONAL MATCH` clause, through the behaviour of that clause when no match is found.
In that case, the pattern variables will be projected with a `NULL` value and subsequent operations using these variables are well-defined.
This CIP builds on these well-established semantics.


=== Syntax

There is no syntactic element to this CIP.
For reference, we include the syntax of the clauses that are able to cause a deleting effect.

[source, ebnf]
----
<delete> = ["DETACH"], "DELETE", <expression> ;
----


=== Semantics

The semantics of a deleted element are exactly the same as if the element variable was mapped to a `NULL` value.
In this section, we will describe detailed semantics for the access of particularly interesting aspects of elements.


==== Properties

Accessing properties of deleted elements produces a `NULL` value, just like accessing a property from a `NULL` value would.
This includes both a direct property access operator (`.`) and the `properties()` function.


==== Node labels

A node label expression using the colon operator (`:`) on a deleted node evaluates to `NULL`.
The `labels()` function on a deleted node evaluates to `NULL`.


==== Relationship type

A relationship type expression using the colon operator (`:`) on a deleted relationship evaluates to `NULL`.
The `type()` function on a deleted relationship evaluates to `NULL`.


==== Pattern matching using deleted elements

When a pattern used for matching in the graph contains an already-bound variable that refers to a deleted element, this results in the same predicate as otherwise, but with semantics that are identical to the case when a `NULL` value would be held by that variable.

For example, consider the pattern `(a)-[r]->()` where the binding table contains bindings for `a` and `r`.
There is an implicit predicate for the pattern matching allowing only elements `n` and `m` in the `a` and `r` positions for which `a = n AND r = m` is `TRUE`.
If `a` and `b` refer to deleted elements, this predicate will not be true for any elements in the database, as the predicate is supposed to evaluate to the same value as `a = NULL AND r = NULL` which is `NULL` and not `TRUE`.


==== Deleting deleted Elements

Deleting a deleted element (like any `NULL` value) is a no-op.


==== Equality of deleted Elements

The normal semantics is that two `NULL` values are never considered equal.
This extends to deleted elements, since they are equivalent to `NULL` for all intents and purposes.

[source, cypher]
.This query returns `same1: *true*; same2: *false*` for all rows
----
MATCH (n), (m)
WHERE n = m AND NOT EXISTS { (n)-() }
WITH n, m, n = m AS same1
DELETE n
RETURN same1, n = m AS same2
----

==== Deleted elements in paths

If an element is deleted that is part of a path value, such a path can no longer exist, therefore the path value is to be treated as _effectively_ `NULL` (in the same way that the deleted element that is part of it would).

[source, cypher]
.This query returns `a: *null*; b: *null*; c: *null*` for all rows
----
MATCH p=()-[r]->()
DELETE r
RETURN p AS a, nodes(p) AS b, relationships(p) AS c
----


==== Deleted elements in nested structures

If an element exists within a list or map or another nested structure, the semantics still apply.


=== Examples

//For each aspect of the proposed feature(s), provide at least one Cypher example query to show how the feature is envisaged to work, along with explanatory text.
//
//_An example of this is shown below._
//
//Find all persons whose name starts with "And":
//[source, cypher]
//----
//MATCH (a:Person)
//WHERE a.name STARTS WITH “And”
//RETURN a
//----
//
//Find all persons whose name starts with the parameter prefix:
//[source, cypher]
//----
//MATCH (a:Person)
//WHERE a.name STARTS WITH {prefix}
//RETURN a
//----
//
//Find all persons whose name ends with "fan":
//[source, cypher]
//----
//MATCH (a:Person)
//WHERE a.name ENDS WITH "fan"
//RETURN a
//----
//
//Find all books whose isbn in string form contains "007":
//[source, cypher]
//----
//MATCH (b:Book)
//WHERE toString(b.isbn) CONTAINS "007"
//RETURN a
//----

=== Interaction with existing features

//Provide details on any interactions that need to be considered.

=== Alternatives

//List any alternatives here; e.g. new keywords, a smaller feature set etc.

== What others do

//If applicable, include a feature comparison table, along with any useful links.
//
//To provide a well-rounded comparison, please ensure the inclusion of at least one SQL-based implementation -- such as DB2 or Postgres -- as well as SPARQL.
//If you require any assistance or pointers to the latter, please contact petra.selmer@neotechnology.com.

== Benefits to this proposal

//List the benefits here.

== Caveats to this proposal

//List any caveats here.
//These may include omissions, reasons for non-conformance with other features and so on.

== Appendix

//Put any supplementary information here.
