= CIP2021-08-10 Operator precedence
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Hannes Voigt <hannes.voigt@neo4j.com>


[abstract]
.Abstract
--
This CIP defines the operator precedence rules of openCypher.
--

toc::[]

== Background

The expression sub-languages of openCypher (and most other query and programming languages) allow very liberal composition of different elementary expressions into complex expressions through nesting.
Elementary expression the kinds of expressions the expression sub-languages provides and which for the building blocks of the sub-languages.

Some elementary expressions have zero operands, e.g. literals.
Most elementary expressions have one or more operands.
For instance,

- A arithmetic negation has one operand,
- A boolean conjunction has two operands,
- A property access has two operands -- an element and a property key,
- A function call has two operands -- a function name and an arguments list,
- A list comprehension has three or four operands -- an element variable name, a list, a predicate, and optionally a projection expression
- A case expression has multiple operands -- a value to test, for every case a test value/predicate and a result value, and a default value of the 'else' case

Some operands expect non-values, typically identifiers (variable names, function names, property keys, etc.).
Such _non-value operands_ do not allow nesting of expressions because expression only result in values.

However, most operands expect values of some types.
Such _value operands_ allow nesting of all expressions that result in a values of the expected type.
The nested expressions form an _operator tree_ and which typically evaluated bottom-up, i.e. all expressions that provide an operand are evaluated before the expression is evaluated that take this operands.
(Higher-order expression, e.g. list comprehensions, have operands which are exceptions to this bottom-up evaluation.)
In other words, the operator tree encodes the evaluation order.
For instance, the following operator tree
----
    *
   / \
  +   4
 / \
3   2
----
encodes that the numeric addition is evaluated before the numeric multiplication, so that the expression results in `20`.

However, the query string is a sequence of characters and not a tree.
The parser turns the query string into such an operator tree.
In the query string, nesting can clearly be denoted by parentheses.
For instance, the query string
----
((3+2)*4)
----
allows a parser to unambiguously construct the operator tree shown above.

For user convenience, better readability, and familiarity with common conventions in mathematical notation, openCypher (and most other query and programming languages) allows omitting the parentheses.
For instance,
----
3+2*4
----
is also a valid expression.

Without additional rules, however, it is not possible to unambiguously construct a operator tree for such an expression.
In the particular case, two operator trees are possible:

- `((3+2)*4)`
- `(3+(2*4))`

To avoid this kind of ambiguity, openCypher (and most other query and programming languages) has _precedence rules_.

Precedence rules (or _rules of operator precedence_) define the order in which the different operators, i.e. the different kinds of expressions, are evaluated.
For instance, numeric multiplication is evaluated before numeric addition, such that expression
----
3+2*4
----
is effectively evaluated as
----
(3+(2*4))
----
and, hence, results in `11` (rather than `20`).

This CIP states the precedence rules of openCypher.

== Proposal

The precedence in openCypher is defined by (1) _precedence levels_ and (2) _intr level precedence_.
Both are defined in the following two subsections.

=== Precedence levels

The following <<precedenceLevels,table>> lists the precedence levels in descending order.

.[[precedenceLevels]]Precedence levels
[cols="<.<1a,<.<4a,<.<4a", options="header"]
|===
|Level         |Group         |Operators

|12
|Atoms
|

* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Literal[Literals]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Variable[Variables]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Parameter[Parameters]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=CaseExpression[Case expressions]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ListComprehension[List comprehensions]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=PatternComprehension[Pattern comprehensions]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Reduce[Reduce operations]
* quantifiers
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=RelationshipsPattern[Pattern predicates]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ParenthesizedExpression[Function invocations]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ParenthesizedExpression[Existential subqueries]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ParenthesizedExpression[Parenthesized expression]

|11
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=PropertyOrLabelsExpression[Graph element operations]
|

* property lookup
* label expressions

.3+|10
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=StringOperatorExpression[String operations] (left-hand operand)
|

* Prefix predicate (and right-hand operand)
* Suffix predicate (and right-hand operand)
* Contains predicate (and right-hand operand)
* Regular expression predicate

|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=StringOperatorExpression[List operations] (left-hand operand)
|

* List element containment predicate (and right-hand operand)
* List element access
* List slicing

|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=NullOperatorExpression[Null operations] (left-hand operand)
|

* Null predicate
* Not-null predicate

|9
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=UnaryAddOrSubtractExpression[Arithmetic additive inverse]
|

* Unary negative
* Unary positive

|8
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=PowerOfExpression[Exponentiation] (left-hand and right-hand operand)
|

* Exponentiation

|7
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=MultiplyDivideModuloExpression[Arithmetic multiplicative operations] (left-hand and right-hand operand)
|

* Multiplication
* Division
* Modulo

|6
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=AddOrSubtractExpression[Arithmetic additive operations] (left-hand and right-hand operand)
|

* Addition
* Substraction

|5
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ComparisonExpression[Comparison operations] (left-hand and right-hand operand)
|

* Equal
* Unequal
* Greater
* Greater or Equal
* Less
* Less or Equal

|4
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=NotExpression[Boolean negation]
|

* Negation

|3
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=AndExpression[Boolean conjunction] (left-hand and right-hand operand)
|

* Conjunction

|2
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=XorExpression[Boolean exclusive disjunction] (left-hand and right-hand operand)
|

* Exclusive disjunction

|1
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=OrExpression[Boolean inclusive disjunction] (left-hand and right-hand operand)
|

* Inclusive disjunction

|===

[IMPORTANT]
.Rule of precedence levels
====
Operators on level _X_ take precedence over any operator on level _Y_, when _X_ > _Y_, i.e. are of higher precedence.
Operators can only directly accept operators of higher precedence as operands.
====

The rule of precedence levels is enforced by the grammar.

The rule of precedence levels does not apply to all operands, though.
The table points out to which operands (left-hand or left-hand and right-hand) the rule of precedence levels apply.

If an operator has operands to which the precedence levels do not apply, these operands are syntactically delineate such that there is no ambiguity with regard to the operator tree.
For instance, the syntax of the list element access clearly delineates the list element index operand by brackets, e.g. `myList[5]`.
Such clearly delineated operands grammatically allow an expression of any precedence level, i.e. grammar encodes the operand as https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Expression[<Expression>].

A prominent expression with a clearly delineated operand is the _parenthesized expression_.
The parenthesized expression has a single operand delineated by parentheses, i.e. `( n.prop+6 )` where `n.prop+6` is the delineated operand.
The parenthesized expression has no other purpose than grammatically allowing expressions as operands that do not meet the rule of precedence levels.
For instance, an arithmetic addition cannot be directly an operand to an arithmetic multiplication by the rule of precedence levels, since addition is of lower precedence than multiplication.
However, with the help of a parenthesized expression, the user can denote
----
3+(2*4)
----
as a valid expression.
This achieves the desire operator tree
----
    *
   / \
 ( )  4
  |
  +
 / \
3   2
----
where the arithmetic addition is an operand to the arithmetic multiplication and, hence, results in `20` (rather than `11`).

=== Intra level precedence

Most precedence level include multiple operators.

On some levels these operators are grammatical alternatives, e.g. for https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Atom[<Atom>s], and, hence, have unambiguous precendence.

On other levels, however, the grammar allows repetitions of such operators (chaining).
For instance, all the following are valid expressions:

* `--+-5`
* `5 + 4 + 3`
* `5 - 4 - 3`
* `5 - 4 + 3`
* `5 * 4 * 3`
* `5 / 4 / 3`
* `5 % 4 % 3`
* `5 % 4 * 3`
* `5 > 4 >= 3`
* `list[4..20][2..5][3]`

Such chained expression fall into four categories:

==== Chaining unary operators
Unary operators that allow chaining on the same precedence level are

* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=UnaryAddOrSubtractExpression[Arithmetic additive inverse]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=NotExpression[Boolean negation]

Example expression are

* `--+-5`
* `NOT NOT NOT false`

[IMPORTANT]
.Chaining of unary operators
====
The chaining of unary operators has unambiguous operator tree.
====

==== Chaining the same associative operator
Associative operators that allow chaining are

* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=MultiplyDivideModuloExpression[Multiplication]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=AddOrSubtractExpression[Addition]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=AndExpression[Boolean conjunction]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=OrExpression[Boolean inclusive disjunction]

Example expression are

* `5 + 4 + 3`
* `5 * 4 * 3`
* `TRUE AND FALSE AND TRUE`
* `TRUE OR FALSE OR TRUE`

[IMPORTANT]
.Chaining of the same associative operator
====
For chains of the same associative operator all possible operator trees are semantically equivalent.
====

Consequently, the example evaluate as follows:

[cols="2a,1a"]
|====
|
[source, cypher]
----
RETURN  5 + 4 + 3  AS a,
       (5 + 4)+ 3  AS b,
        5 +(4 + 3) AS c
----
|
[options="header"]
!====
!a !b !c
!12!12!12
!====

|
[source, cypher]
----
RETURN  5 * 4 * 3  AS a,
       (5 * 4)* 3  AS b,
        5 *(4 * 3) AS c
----
|
[options="header"]
!====
!a !b !c
!60!60!60
!====

|
[source, cypher]
----
RETURN  TRUE AND FALSE  AND TRUE  AS a,
       (TRUE AND FALSE) AND TRUE  AS b,
        TRUE AND (FALSE AND TRUE) AS c
----
|
[options="header"]
!====
!a    !b    !c
!false!false!false
!====

|
[source, cypher]
----
RETURN  TRUE OR FALSE  OR TRUE  AS a,
       (TRUE OR FALSE) OR TRUE  AS b,
        TRUE OR (FALSE OR TRUE) AS c
----
|
[options="header"]
!====
!a   !b   !c
!true!true!true
!====

|====


==== Chaining non-associative or mixed operators
Non-associative operators that allow chaining with themselves of other operators on the same precedence level are

* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=StringListNullOperatorExpression[String, list, and null operations] (where type-compatible)
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=PowerOfExpression[Exponentiation]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=MultiplyDivideModuloExpression[Division]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=MultiplyDivideModuloExpression[Modulo]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=AddOrSubtractExpression[Substraction]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=OrExpression[Boolean exclusive disjunction]

Example expression are

* `list[4..20][2..5][3]`
* `'foo' STARTS WITH 'fo' IS NOT NULL`
* `5 ^ 4 ^ 3`
* `5 / 4 / 3`
* `5 % 4 % 3`
* `5 % 4 * 3`
* `5 - 4 - 3`
* `5 + 4 - 3`
* `TRUE XOR TRUE XOR FALSE`

[IMPORTANT]
.Chaining of non-associative or mixed operators
====
In chains of non-associative or mixed operators, for every two operators, the operator appear earlier (more left) in the character string takes precedence, i.e. the operator tree is left-deep.
====

==== Chaining with extra semantics
Operators whose chaining gives extra semantics are

* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ComparisonExpression[Comparison operations]

Example expression are

* `5 = 5 = 5`
* `5 = 4 <> 3`
* `5 <> 4 > 3`
* `5 > 4 > 3`
* `5 > 4 >= 3`
* `5 >= 4 < 3`

[IMPORTANT]
.Chaining with extra semantics
====
Chains with extra semantics, either

a. form a flat operator tree of a single operator, or
b. their semantics is defined by a syntax transformation to an expression that has an unambiguous operator tree based on the other precedence rules stated in this document.
====



== What others do


== Benefits to this proposal


== Caveats to this proposal


