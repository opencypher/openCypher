= CIP2021-08-10 Operator precedence
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Hannes Voigt <hannes.voigt@neo4j.com>


[abstract]
.Abstract
--
This CIP defines the operator precedence rules of openCypher.
--

toc::[]

== Background

The expression sub-languages of openCypher (and most other query and programming languages) allow very liberal composition of different elementary expressions into complex expressions through nesting.
Elementary expression the kinds of expressions the expression sub-languages provides and which for the building blocks of the sub-languages.

Some elementary expressions have zero operands, e.g. literals.
Most elementary expressions have one or more operands.
For instance,

- A arithmetic negation has one operand,
- A boolean conjunction has two operands,
- A property access has two operands -- an element and a property key,
- A function call has two operands -- a function name and an arguments list,
- A list comprehension has three or four operands -- an element variable name, a list, a predicate, and optionally a projection expression
- A case expression has multiple operands -- a value to test, for every case a test value/predicate and a result value, and a default value of the 'else' case

Some operands expect non-values, typically identifiers (variable names, function names, property keys, etc.).
Such _non-value operands_ do not allow nesting of expressions because expression only result in values.

However, most operands expect values of some types.
Such _value operands_ allow nesting of all expressions that result in a values of the expected type.
The nested expressions form an _operator tree_ and which typically evaluated bottom-up, i.e. all expressions that provide an operand are evaluated before the expression is evaluated that take this operands.
(Higher-order expression, e.g. list comprehensions, have operands which are exceptions to this bottom-up evaluation.)
In other words, the operator tree encodes the evaluation order.
For instance, the following operator tree
----
    *
   / \
  +   4
 / \
3   2
----
encodes that the numeric addition is evaluated before the numeric multiplication, so that the expression results in `20`.

However, the query string is a sequence of characters and not a tree.
The parser turns the query string into such an operator tree.
In the query string, nesting can clearly be denoted by parentheses.
For instance, the query string
----
((3+2)*4)
----
allows a parser to unambiguously construct the operator tree shown above.

For user convenience, better readability, and familiarity with common conventions in mathematical notation, openCypher (and most other query and programming languages) allows omitting the parentheses.
For instance,
----
3+2*4
----
is also a valid expression.

Without additional rules, however, it is not possible to unambiguously construct a operator tree for such an expression.
In the particular case, two operator trees are possible:

- `((3+2)*4)`
- `(3+(2*4))`

To avoid this kind of ambiguity, openCypher (and most other query and programming languages) has _precedence rules_.

Precedence rules (or _rules of operator precedence_) define the order in which the different operators, i.e. the different kinds of expressions, are evaluated.
For instance, numeric multiplication is evaluated before numeric addition, such that expression
----
3+2*4
----
is effectively evaluated as
----
(3+(2*4))
----
and, hence, results in `11` (rather than `20`).

This CIP states the precedence rules of openCypher.

== Proposal

The precedence in openCypher is defined by (1) _precedence levels_ and (2) _left-to-right precedence_.
Both are defined in the following.

=== Precedence levels

The following <<precedenceLevels,table>> lists the precedence levels in descending order.

.[[precedenceLevels]]Precedence levels
[cols="<.<1a,<.<4a,<.<4a", options="header"]
|===
|Level         |Group         |Operators

|12
|Atoms
|

* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Literal[literals]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Variable[variables]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Parameter[parameters]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=CaseExpression[case expressions]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ListComprehension[list comprehensions]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=PatternComprehension[pattern comprehensions]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Reduce[reduce operations]
* quantifiers
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=RelationshipsPattern[pattern predicates]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ParenthesizedExpression[function invocations]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ParenthesizedExpression[existential subqueries]
* https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ParenthesizedExpression[parenthesized expression]

|11
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=PropertyOrLabelsExpression[Graph element operations]
|

* property lookup
* label expressions

.3+|10
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=StringOperatorExpression[String operations] (left-hand operand)
|

* Prefix predicate (and right-hand operand)
* Suffix predicate (and right-hand operand)
* Contains predicate (and right-hand operand)
* Regular expression predicate

|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=StringOperatorExpression[List operations] (left-hand operand)
|

* List element containment predicate (and right-hand operand)
* List element access
* List slicing

|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=NullOperatorExpression[Null operations] (left-hand operand)
|

* Null predicate
* Not-null predicate

|9
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=UnaryAddOrSubtractExpression[Arithmetic additive inverse]
|

* Unary negative
* Unary positive

|8
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=PowerOfExpression[Exponentiation] (left-hand and right-hand operand)
|

* Exponentiation

|7
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=MultiplyDivideModuloExpression[Arithmetic multiplicative operations] (left-hand and right-hand operand)
|

* Multiplication
* Division
* Modulo

|6
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=AddOrSubtractExpression[Arithmetic additive operations] (left-hand and right-hand operand)
|

* Addition
* Substraction

|5
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=ComparisonExpression[Comparison operations] (left-hand and right-hand operand)
|

* Equal
* Unequal
* Greater
* Greater or Equal
* Less
* Less or Equal

|4
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=NotExpression[Boolean negation] (left-hand and right-hand operand)
|

* Negation

|3
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=AndExpression[Boolean conjunction] (left-hand and right-hand operand)
|

* Conjunction

|2
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=XorExpression[Boolean exclusive disjunction] (left-hand and right-hand operand)
|

* Exclusive disjunction

|1
|https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=OrExpression[Boolean inclusive disjunction] (left-hand and right-hand operand)
|

* Inclusive disjunction

|===

[IMPORTANT]
.Rule of precedence levels
====
Operators on level _X_ take precedence over any operator on level _Y_, when _X_ > _Y_, i.e. are of higher precedence.
Operators can only directly accept operators of higher precedence as operands.
====

The rule of precedence levels is enforced by the grammar.

The rule of precedence levels does not apply to all operands, though.
The table points out to which operands (left-hand or left-hand and right-hand) the rule of precedence levels apply.

If an operator has operands to which the precedence levels do not apply, these operands are syntactically delineate such that there is no ambiguity with regard to the operator tree.
For instance, the syntax of the list element access clearly delineates the list element index operand by brackets, e.g. `myList[5]`.
Such clearly delineated operands grammatically allow an expression of any precedence level, i.e. grammar encodes the operand as https://raw.githack.com/openCypher/openCypher/master/tools/grammar-production-links/grammarLink.html?p=Expression[<Expression>].

A prominent expression with a clearly delineated operand is the _parenthesized expression_.
The parenthesized expression has a single operand delineated by parentheses, i.e. `( n.prop+6 )` where `n.prop+6` is the delineated operand.
The parenthesized expression has no other purpose than grammatically allowing expressions as operands that do not meet the rule of precedence levels.
For instance, an arithmetic addition cannot be directly an operand to an arithmetic multiplication by the rule of precedence levels, since addition is of lower precedence than multiplication.
However, with the help of a parenthesized expression, the user can denote
----
3+(2*4)
----
as a valid expression.
This achieves the desire operator tree
----
    *
   / \
 ( )  4
  |
  +
 / \
3   2
----
where the arithmetic addition is an operand to the arithmetic multiplication and, hence, results in `20` (rather than `11`).

=== Left-to-right precedence

== What others do


== Benefits to this proposal


== Caveats to this proposal


