= CIP2016-06-14 - Harmonize Comparability, Orderability, Equality, and Equivalence
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Mats Rydberg <mats@neotechnology.com>, Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP intends to introduce and formalise two new concepts, *comparability* and *orderability*, and defines their relationship to the already existing concepts of *equality* and *equivalence*.
Comparability revolves around the inequality operators (`>`, `<`, `>=`, `<=`), and defines the semantics they need to properly determine how two values compare to each other.
Orderability revolves around the `ORDER BY` clause, and defines the semantics it needs to be able to properly sort values passed to it.
Futhermore, the definitions of *equality* and *equivalence* are harmonized and spelled out.
In summary, we are proposing some changes to how Cypher defines these four concepts in order to get a consistent set of rules and a simpler conceptual model.
--

toc::[]


== Motivation

There are currently a number of limitations and inconsistencies that this CIP aims to fix.

(1) Cypher already has good semantics for equality within the primitive types (booleans, strings, integers, and floats) and maps.
Furthermore, Cypher has good semantics for comparability and orderability for integers, floats, and strings, within the types.
However working with values of different types can be difficult:

  * Comparability between values of different types is often undefined, which is something we regard as a problem for certain combinations of values and types.
  * `ORDER BY` will often fail with an error if the values passed to it have different types.

(2) The underlying conceptual model is complex and sometimes inconsistent which leads to an unclear relationship between comparison operators, equality, grouping, and `ORDER BY`:

  * Comparability and orderability are not aligned with each other consistently (Some types may be ordered but not compared).
  * There are various inconsistencies around equality (and equivalence) semantics as exposed by `IN`, `=`, `DISTINCT`, and grouping.
  The difference between equality and equivalence in Cypher today is small and subtle, and limited to testing two instances of the value `null` to each other.

    ** In equality, `null = null` is `null`.
    ** In equivalence, used by grouping and `DISTINCT`, instances of `null` are always treated as being the same value.
    ** However, equality treats `null` values differently if they are an element of a list or a map value.
    ** Similar rules apply for `NaN`.

== Proposal

=== Comparability

We propose that comparability be defined between any pair of values, as specified below (Please note that `null` is interpreted as meaning "unknown" or "could be any value" in the context of comparability):

* Integers are compared numerically.
* Floats (excluding `NaN` and the Infinities) are compared numerically.
* Arbitrary numbers (excluding `NaN` and the Infinities) are compared to each other numerically, i.e. the comparison behaves as if both numbers would have been coerced to arbitrary precision big decimals (currently outside the Cypher type system) before comparing them with each other numerically.
* Positive infinity is of type `FLOAT`, equal to itself and larger than any other number (excluding `NaN`).
* Negative infinity is of type `FLOAT`, equal to itself and smaller than any other number (excluding `NaN`).
* Comparing a number to a `NaN` always yields `null`.
* Booleans are compared such that `false < true`.
* Strings are compared in dictionary order, i.e. characters are compared pairwise in order and characters missing in a shorter string are considered to be smaller than any other character. For example, `'a' < 'aa'`.
* Lists are compared in dictionary order, i.e. list elements are compared pairwise in order and elements missing in a shorter list are considered to be smaller than any other value. For example, `[1] < [1,0]`.
* Lists containing `null` values are incomparable, i.e. comparing them with any other value yields `null`.
* Maps are compared as if they where lists of lists, where the inner lists are the key-value pairs of the maps, ordered in ascending sort order for the keys. Comparing a map to a value that is not a map always yields `null`.
* Maps containing explicit `null` value entries are incomparable, i.e. comparing them with any other value yields `null`.
* The comparison order for nodes (and relationships resp.) is undefined, and an implementation may choose an order for these freely, e.g. by using some kind of id. This order must not change during the execution of the query (i.e. it must be stable in the presence of updates). Comparing a node to a relationship always yields `null`.
* Paths are compared as if they where a list of alternating nodes and relationships of the path from the start node to the end node. Comparing a path to a value that is not a path always yields `null`.
* Implementations may choose to define suitable comparability rules for values of additional, non-canonical types. However comparing a value of an additional, non-canonical type to any of the canonical types always yields `null`.
* Comparing any kind of value not covered above to an arbitrary other value, always yields `null`. This includes comparing a non-`null` value to a `null` value.

=== Orderability

We further propose that orderability be defined between any pair of values, where the result is always `true` or `false`; i.e. always defined.
To accomplish this, there must be a pre-determined type order and each value must fall under exactly one type in this order. We propose to use the following ascending global sort order of types:

* `NODE`
* `RELATIONSHIP`
* `PATH`
* `MAP`
* `LIST OF ANY?`
* `STRING`
* `BOOLEAN`
* `NUMBER` (`NaN` is treated as the largest number in orderability only, i.e. it is put after positive infinity)
* `VOID` (i.e. the type of `null`)

Within the types, orderability defers to comparability with two exceptions:
* Two `null` values are treated as the same value in accordance with the global sort order
* Two `NaN` values are treated as the same value in accordance with the global sort order

The accompanying descending global sort oder is the same order in reverse (i.e. it runs from `VOID` to `NODE`).

Any additionally introduced non-canonical types introduced by an implementation should be inserted between `PATH` and `MAP` in the global sort order. As an exception, additionally introduced non-canonical number types may be integrated under the `NUMBER` type in the global sort order.

=== Equality ===

We propose that equality and comparability must be aligned, i.e. `l = r` if and only if `l <= r && l >= r`.

To achieve this, we unify the difference between equality and equivalence, by making lists containing `null` values follow the same difference as the `null` values themselves.

Concretely, we propose to redefine how equality works for lists in Cypher today.
To determine if two lists `l1` and `l2` are equal, we propose two simple tests, like so

* `l1` and `l2` must have the same size, i.e. inversely `size(l1) <> size(l2>) => l1 <> l2`
* the pairwise elements of both `l1` and `l2` must be equal, i.e.
----
[a1, a2, ...] = [b1, b2, ...]
<=>
a1 = b1 && a2 = b2 && ...
----

For clarity, we also repeat the current equality semantics of maps here (at the time of writing this CIP). Two maps `m1` and `m2` are considered equal if

* `m1` and `m2` must have the same keys.
* For each key `k`,
** either `m1.k = m2.k` is `true`,
** or both `m1.k IS NULL` and `m2.k IS NULL`

This is at odds with the common interpretation of `null` as standing for any possible value.

It is aligned though with the most common use case for maps with `null` entries which is to update multiple properties at once, e.g. `SET n += { n: 12, remove_this_key: null }`. In this case, there is no need to differentiate between different `null` values as `null` merely serves as a marker for keys to be removed. Current equality semantics makes it easy to check if two maps correspond to the same property update in this scenario.

However this type of update map comparison is rare and could be emulated using a more complex predicate. The current rules do however break symmetry with how equality handles `null` in all other cases. This becomes more apparent by considering these two examples

* `expr1 = expr2` => `null` if `expr1 IS null && expr2 IS NULL`
* `{a: expr1} = {a: expr2}` => `true` (!!) if `expr1 IS null && expr2 IS NULL`

To fix this, we propose that two maps `m1` and `m2` instead should be equal if

* `m1` and `m2` have the same keys (the order of keys as returned by `keys` does not matter)
* For each such key `k`, `m1.k = m2.k`

As a consequence of these changes, plain equality is not reflexive in a classic sense (Consider: `{a: null} = {a: null}`, `[null] = [null]`). However this was already the case (Consider: `null = null` => `null`).

However, Equality is reflexive for values that do not involve `null`.

=== Equivalence ===

Equivalence remains unchanged but now can be defined succinctly as being identical to equality except that:
* Any two `null` values are treated as equivalent (both directly or inside nested structures).
* Any two `NaN` values are treated as equivalent (both directly or inside nested structures).

Note that orderability is aligned with equivalence, i.e. equivalent values have the same position under orderability.

Equivalence is reflexive for all values.

=== Summary of Conceptual Model

This proposal aims to simplify the conceptual model around equality, comparison, sorting, and grouping:

* Equality: Equality follows natural, literal equality. However, values involving `null` are never equal. Nested structures are first tested for equality by shape (keys, size) and then componentwise. This ensures that equality is compatible with interpreting `null` as "unknown" or "could be any value".
* Comparability: Comparability is aligned with equality. Two values of the same type in the global sort order are always comparable. Two values of different types are always incomparable and values involving `null` are always incomparable.
This ensures that `MATCH (n) WHERE n.prop > 42` will never find nodes where `n.prop` is of type `STRING`.
* Equivalence: Equivalence is a form of equality that treats `null` (and `NaN`) values as identical. Equivalence is used in grouping and `DISTINCT` where `null` commonly is interpreted as a marker that a value was missing instead of as a wildcard for any possible value.
* Orderability follows comparability but additionally defines a global sort order between values of different types and is aligned with equivalence regarding the handling of `null` and `NaN` values.

=== Examples

An integer compared to a float
[source, cypher]
----
RETURN 1 > 0.5 // should be true
----

A string compared to a boolean
[source, cypher]
----
RETURN 'string' <= true // should be null
----

Ordering values of different types
[source, cypher]
----
UNWIND [1, true, '', 3.14, {}, [2]] AS i
RETURN i
  ORDER BY i // should not crash
----

Filtering distinct values of different types
[source, cypher]
----
UNWIND [[null], [null]] AS i
RETURN DISTINCT i // should return exactly one row
----

=== Interaction with existing features

The concept of orderability is used only by `ORDER BY` in Cypher today.
The concept of comparability is used by the comparisons operators `<`, `>`, `<=`, >=`.

One major goal of our proposal is for equality semantics to align well with comparability.
The concept of equality is used by the equality operator `=`, the inequality operator `<>`, value joins, and the `IN` operator.
The concept of equivalence is used by the `DISTINCT` clause modifier and in grouping.

With the proposals made in this CIP, specifically changing equality for lists, the mentioned functionality is going to treat lists containing `null` as unequal, thus potentially filtering out more rows when used in a predicate.

=== Alternatives

Columns in SQL are always have a concrete type. This removes the need to define a global sort order between types. Standard SQL has no support for lists, maps, or graph structures and hence does not need to define semantics for them.
SQL also treats comparisons involving `null` as returning `null`.

PostgresSQL treats some numerical operations (like division by zero) that would compute a `NaN` as a numerical error that fails the query. PostgresQL considers `NaN` to be larger than positive infinity, both in comparison and in sort order. This proposal achieves something very similar by evaluating comparisons involving a `NaN` to `null` and by treating both `NaN` and `null` as the largest values in the global sort order.

This proposal could be extended with an operator for making equivalence accessible beyond use in grouping and `DISTINCT`. This seems desirable due to plain `=` not being reflexive for all values.

Also noteworthy: If nulls would track their source, equality could become reflexive again as it would become possible to know if two `null` values represent the same "unknown" value.

== Benefits to this proposal

A consistent set of rules for equality, equivalence, comparability and orderability.

== Caveats to this proposal

Adopting this proposal may break some queries; specifically queries that depend on equality semantics of lists containing `null` values.
It should be noted that we expect that most lists used in queries are constructed using `collect()`, which never outputs `null` values.

== Appendix: Comparability by Type

The following table captures which types may be compared with each other such that the outcome is either `true` or `false`.
Any other comparison will always yield `null` (except for `NaN`) which is handled as described above.

.Comparability of values of different types (`X` means the result of comparison will always return `true` or `false`)
[frame="topbot",options="header,footer"]
|===========================================================================================================================================
|Type           | `NODE` | `RELATIONSHIP` | `PATH` | `MAP` | `LIST OF ANY?` | `STRING` | `BOOLEAN` | `NUMBER` | `INTEGER` | `FLOAT` | `VOID`
|`NODE`         | X      |                |        |       |                |          |           |          |           |         |
|`RELATIONSHIP` |        | X              |        |       |                |          |           |          |           |         |
|`PATH`         |        |                | X      |       |                |          |           |          |           |         |
|`MAP`          |        |                |        | X     |                |          |           |          |           |         |
|`LIST OF ANY?` |        |                |        |       | X              |          |           |          |           |         |
|`STRING`       |        |                |        |       |                | X        |           |          |           |         |
|`BOOLEAN`      |        |                |        |       |                |          | X         |          |           |         |
|`NUMBER`       |        |                |        |       |                |          |           | X        | X         | X       |
|`INTEGER`      |        |                |        |       |                |          |           | X        | X         | X       |
|`FLOAT`        |        |                |        |       |                |          |           | X        | X         | X       |
|`VOID`         |        |                |        |       |                |          |           |          |           |         |
|===========================================================================================================================================
`
