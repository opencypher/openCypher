= CIP2016-06-14 - Redefine Comparability and Equality, as well as Orderability and Equivalence
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Mats Rydberg <mats@neotechnology.com>, Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP redefines and formalizes 4 key lanugage concepts, *comparability* and *equality*, as well as *orderability* and *equivalence*. While these notions already exist in the language today, they have never been defined explicitly.
Furthermore the current definitions are somewhat misaligned with each other. This leads to inconsistencies and an unnecessarily complicated conceptual model. In summary, this CIP proposes some changes to how Cypher defines these four concepts in order to get a consistent set of rules and also proposes to align comparability with equality, as well as orderability with equivalence to provide a simpler conceptual model.
--

toc::[]

== Motivation

There are currently a number of limitations and inconsistencies that this proposal aims to address:

1. Cypher already has good semantics for equality within the primitive types (booleans, strings, integers, and floats) and maps.
Furthermore, Cypher has good semantics for comparability and orderability for integers, floats, and strings, within each of the types.
However working with values of different types can be difficult:

  * Comparability between values of different types is often undefined. This stops query execution instead of allowing graceful recovery. This problem is particularly pronounced when it occurs as part of the evaluation of predicates (in `WHERE`).
  * `ORDER BY` will often fail with an error if the values passed to it have different types.

2. The underlying conceptual model is complex and sometimes inconsistent. This leads to an unclear relationship between comparison operators, equality, grouping, and `ORDER BY`:

  * Comparability and orderability are not aligned with each other consistently, as some types may be ordered but not compared.
  * There are various inconsistencies around equality (and equivalence) semantics as exposed by `IN`, `=`, `DISTINCT`, and grouping.
  The difference between equality and equivalence in Cypher today is small and subtle, and limited to testing two instances of the value `null` to each other.

  ** In equality, `null = null` is `null`.
  ** In equivalence, used by `DISTINCT` and when grouping values, two `null` values are always treated as being the same value.
  ** However, equality treats `null` values differently if they are an element of a list or a map value.
  ** Similar rules apply for `NaN`.

Furthermore, the key concepts comparability, orderability, equality, and equivalence have never been defined properly.  Therefore another motivation for this CIP is to unambiguously and precisely define these 4 concepts.

== Background

The reader should be mindful of the Cypher type system when reading this CIP. At the time of this proposal, the latest CIP regarding the Cypher type system is: https://github.com/opencypher/openCypher/blob/master/cip/CIP2015-09-16-public-type-system-type-annotation.adoc[`CIP2015-09-16-public-type-system-type-annotation`].

== Proposal

We propose to redefine <<comparability-def>> and <<equality-def>>, as well as <<orderability-def>> and <<equivalence-def>> as detailed in this section.

[[concepts]]
=== Concepts

Cypher today features four distinct concepts related to equality and ordering:

[horizontal]
[[comparability-con,comparability (concept)]]*Comparability*:: <<comparability-def,Comparability>> revolves around the inequality operators (`>`, `<`, `>=`, `\<=`), and defines the semantics they need to properly determine how two values compare to each other.
[[equality-con,equality (concept)]]*Equality*:: <<equality-def,Equality>> revolves around the equality operators ('=', '<>') as well as the list membership operator (`IN`) and value joins, and defines the semantics the needed to properly determine if two values are the same.
Equality is also used implicitly by literal maps in node and relationship patterns, since such literal maps are merely a shorthand notation for equality predicates.
[[orderability-con,orderability (concept)]]*Orderability*:: <<orderability-def,Orderability>> revolves around the `ORDER BY` clause, and defines the semantics it needs to be able to properly sort values passed to it.
[[equivalence-con,equivalence (concept)]]*Equivalence*:: <<equivalence-def,Equivalence>> revolves around the `DISTINCT` modifier and grouping in projection clauses (`WITH`, `RETURN`), and defines the semantics they need to properly determine if two values are the same.

==== The meaning of `null`

For the following discussion, it is helpful to clarify the meaning of `null`. In Cypher, a `null` value has one of two meanings, depending on the context in which it occurs:

[horizontal]
[[unknown-null,unknown `null`]]*Unknown*:: An "unknown" `null` is taken to be a placefolder for an arbitrary but unknown value. When evaluating predicates, an "unknown" `null` is the `maybe` truth value of ternary logic. For node and relationship properties, an "unknown" `null` is a value that is definite in the real world but has not been stored in the graph. Since in these cases, two "unknown" `null` values stand for arbitrary but definite values in the real world, two "unknown" `null` values should never be treated as certainly being the same value.
[[missing-null,missing `null`]]*Missing*:: A "missing" `null` is taken to be a marker for the absence of a value. In the context of updating node properties from a map, a "missing" `null` is used to mark properties that are to be removed. In the context of `DISTINCT` and grouping, a "missing" `null` value is used as grouping key for all records that miss a more specific value. Since in these cases, two "missing" `null` values represent the same concept, they should always be treated as the same value.

[[regular-maps]]
==== Regular maps

Cypher today has one supertype `MAP` for all map values. This includes nodes (of subtype `NODE`), relationships (of subtype `RELATIONSHIP`), and any other map (not captured by a subtype of `MAP`). For the purpose of this document, we define a regular map to be any value of type `MAP` that is neither a `NODE` nor a `RELATIONSHIP`.

<<comparability-equality,comparability and equality>>
=== Comparability and equality

We propose that comparability and equality should be aligned with each other, i.e.

`expr1 = expr2` if and only if `expr1 >= expr2 && expr1 \<= expr2`.

Comparability and equality use <<unknown-null,"unknown" `null` values>>.

[[incomparable,incomparable]]
==== Incomparability

We define that a value is incomparable if and only if any comparison or equality test involving this value evaluates to `null`.

We further define a pair of values to be incomparable if and only if any comparison or equality test between these two values evaluates to `null`.

[[comparability-def,comparability]]
==== Comparability

We propose that <<comparability-con,comparability>> should be defined between any pair of values, as specified below.

- Numbers
  * Integers are compared numerically in ascending order.
  * Floats (excluding `NaN` and the Infinities) are compared numerically in ascending order.
  * Numbers of different types (excluding `NaN` and the Infinities) are compared to each other as if both numbers would have been coerced to arbitrary precision big decimals (currently outside the Cypher type system) before comparing them with each other numerically in ascending order.
  * Positive infinity is of type `FLOAT`, equal to itself and larger than any other number (excluding `NaN`).
  * Negative infinity is of type `FLOAT`, equal to itself and smaller than any other number (excluding `NaN`).
  * `NaN` is <<incomparable>>.
  * Numbers are <<incomparable>> to any value that is not also a number.
- Booleans
  * Booleans are compared such that `false < true`.
  * Booleans are <<incomparable>> to any value that is not also a boolean.
- Strings
  * Strings are compared in dictionary order, i.e. characters are compared pairwise in ascending order from the start of the string to the end. Characters missing in a shorter string are considered to be smaller than any other character. For example, `'a' < 'aa'`.
  * Strings are <<incomparable>> to any value that is not also a string.
- Lists
  * Lists are compared in dictionary order, i.e. list elements are compared pairwise in ascending order from the start of the list to the end. Elements missing in a shorter list are considered to be smaller than any other value. For example, `[1] < [1,0]`.
  * Lists containing `null` values are <<incomparable>>. For example, `[1] >= [1, null]` evaluates to `null`.
  * Lists are <<incomparable>> to any value that is not also a list.
- Maps
  * [[regular-maps,regular maps]]Regular maps
  ** The comparison order for maps is unspecified and left to implementations.
  ** The comparison order for maps must align with the <<equality-def,equality semantics>> outlined below. In consequence, any map that contains an entry that maps it's key to a `null` value is <<incomparable>>. For exampe, `{a: 1} \<= {a: 1, b: null}` evaluates to `null`.
  ** Regular maps are <<incomparable>> to any value that is not also a regular map.
  * Nodes
  ** The comparison order for nodes is unspecified and left to implementations.
  ** Nodes are <<incomparable>> to any value that is not also a node.
  * Relationships
  ** The comparison order for relationships is unspecified and left to implementations.
  ** Relationships are <<incomparable>> to any value that is not also a relationship.
- Paths
  ** Paths are compared as if they were a list of alternating nodes and relationships of the path from the start node to the end node. For example, `[Node(1)-Rel(2)->Node(4)] \<= [Node(1)<-Rel(3)-Node(2)]` (assuming graph entities are sorted in ascending order by an integer id in a given implementation).
  ** Paths track the direction in which a relationship is traversed. Two paths that traverse the same nodes and relationships in the same order but differ in the direction in which they traverse a single relationship are not equal. The comparison order for paths is expected to align with this.
  ** Paths are <<incomparable>> to any value that is not also a path.
- Implementation-specific types
  * Implementations may choose to define suitable comparability rules for values of additional, non-canonical types.
  * Values of an additional, non-canonical type are expected to be <<incomparable>> to values of a canonical type.

Any kind of value not covered here is considered <<incomparable>>. This includes comparing a `null` value to any other value.

[[equality-def,equality]]
==== Equality ====

In order to align equality with <<comparability-def>>, we change equality of lists and maps that contain `null` values to treat those values in the same way as if they would have been compared outside of those lists and maps, as individual, simple values.

Specifically, we propose to redefine how equality works for lists in Cypher.
To determine if two lists `l1` and `l2` are equal, we propose two simple tests, as exemplified by the following:

* `l1` and `l2` must have the same size, i.e. inversely `size(l1) <> size(l2>) \=> l1 <> l2`
* the pairwise elements of both `l1` and `l2` must be equal, i.e.
----
[a1, a2, ...] = [b1, b2, ...]
<=>
a1 = b1 && a2 = b2 && ...
----

For clarity, we also repeat the *current* equality semantics of maps here. Under these current semantics, two maps `m1` and `m2` are considered equal if:

* `m1` and `m2` have the same keys,
** including keys that map to a `null` value (the order of keys as returned by `keys` does not matter here).
* Additionally, for each such key `k`,
** either `m1.k = m2.k` is `true`,
** or both `m1.k IS NULL` and `m2.k IS NULL`

This is at odds with the decision to use <<unknown-null,"unknown" `null` values>> in <<comparability-equality>>.

However, this definition is aligned with the most common use case for maps with `null` entries: updating multiple properties through the use of a single `SET` clause, e.g. `SET n += { size: 12, remove_this_key: null }`. In this case, there is no need to differentiate between different `null` values, as `null` merely serves as a marker for keys to be removed (i.e. is a <<missing-null,"missing" `null` value>>). Current equality semantics make it easy to check if two maps would correspond to the same property update in this scenario. We note though that this type of update map comparison is rare and could be emulated using a more complex predicate. The current rules do however break symmetry with how equality handles `null` in all other cases. This becomes more apparent by considering these two examples:

* `expr1 = expr2` evaluates to `null` if `expr1 IS null && expr2 IS NULL`
* `{a: expr1} = {a: expr2}` evaluates to `true` if `expr1 IS null && expr2 IS NULL`

To rectify this, we propose instead that two maps `m1` and `m2` should be equal if:

* `m1` and `m2` have the same keys,
** including keys that map to a `null` value (the order of keys as returned by `keys` does not matter here).
* Additionally, for each such key `k`,
** `m1.k = m2.k` is `true`.

As a consequence of these changes, plain <<equality-def>> is not reflexive for all values (consider: `{a: null} = {a: null}`, `[null] = [null]`). However this was already the case (consider: `null = null` \=> `null`).

Note that <<equality-def>> is reflexive for values that do not involve `null` though.

[[orderability-equivalence]]
=== Orderability and equivalence ===

We propose that <<orderability-def>> and <<equivalence-def>> should be aligned with each other, i.e.

`expr1` is equivalent to `expr2` if and only if they would be sorted before (or after resp.) any other non-equivalent value in the same way (i.e. they have the same position under orderability).

Orderability and equivalence use <<missing-null,"missing" `null` values>>.

[[orderability-def,orderability]]
==== Orderability ====

[[global-sort-order,global sort order]]
We further propose that orderability be defined between any pair of values, where the result is always `true` or `false`, i.e. always defined.
To accomplish this, there must be a pre-determined order of types and each value must fall under exactly one disjoint leaf type in this order. We propose to use the following ascending global sort order of disjoint types:

* `MAP` types
** <<regular-map,Regular maps>>
** `NODE`
** `RELATIONSHIP`
* `LIST OF ANY?`
* `PATH`
* `STRING`
* `BOOLEAN`
* `NUMBER` (`NaN` is treated as the largest number in orderability only, i.e. it is put after positive infinity)
* `VOID` (i.e. the type of `null`)

To give a concrete example, under this global sort order all Nodes are less than all Strings.

Between values of the same type in the global sort order, orderability defers to comparability except that equality is overriden by equivalence as described below.

The accompanying descending global sort order is the same order in reverse (i.e. it runs from `VOID` to `NODE`).

[[equivalence-def,equivalence]]
==== Equivalence ====

Equivalence remains mostly unchanged but now can be defined succinctly as being identical to equality except that:

* Any two `null` values are equivalent (both directly or inside nested structures).
* Any two `NaN` values are equivalent (both directly or inside nested structures).
* However, `null` and `NaN` values are not equivalent (both directly or inside nested structures).

<<equivalence-def,Equivalence>> is reflexive for all values.

[[conceptual-model]]
=== Summary of the conceptual model ===

This proposal aims to simplify the conceptual model around equality, comparison, order, and grouping:

- <<comparability-equality,Comparability and equality>> are aligned with each other
  * <<comparability-con,Comparability>> ensure that any two values of the same leaf type in the <<global-sort-order>> are comparable. Two values of different types are incomparable and values involving `null` are incomparable, too.
This ensures that `MATCH (n) WHERE n.prop < 42` will never find nodes where `n.prop` is of type `STRING`.
  * <<equality-con,Equality>> follows natural, literal equality. However, values involving `null` are never equal to any other value. Nested structures are first tested for equality by shape (keys, size) and then their corresponding elements are tested for equality pairwise. This ensures that equality is compatible with interpreting `null` as "unknown" or "could be any value" or "undefined".
- <<orderability-equivalence>> are aligned with each other
  * <<orderability-con,Orderability>> follows comparability but additionally defines a <<global-sort-order>> between values of different types and is aligned with equivalence instead of equality, i.e. treats two `null` (resp. `NaN`) values as equivalent.
  * <<equivalence-con,Equivalence>> is a form of equality that treats `null` (and `NaN`) values as the same value. Equivalence is used in grouping and `DISTINCT` where `null` commonly is interpreted as a category marker for results with missing values instead of as a wildcard for any possible value.

=== Examples

An integer compared to a float
[source, cypher]
----
RETURN 1 > 0.5 // should be true
----

A string compared to a boolean
[source, cypher]
----
RETURN 'string' \<= true // should be null
----

Ordering values of different types
[source, cypher]
----
UNWIND [1, true, '', 3.14, {}, [2]] AS i
RETURN i
  ORDER BY i // should not crash
----

Filtering distinct values of different types
[source, cypher]
----
UNWIND [[null], [null]] AS i
RETURN DISTINCT i // should return exactly one row
----

=== Interaction with existing features

Changing <<equality-def>> to treat lists and maps containing `null` as unequal is going to potentially filter out more rows when used in a predicate.

Redefining the <<global sort order>> as well as making all values <<comparability-def,comparable>> will change some currently failing queries to pass.

=== Alternatives

Columns in SQL always have a concrete type. This removes the need to define a <<global-sort-order>> between types. Standard SQL has no support for lists, maps, or graph structures and hence does not need to define semantics for them.
SQL also treats comparisons involving `null` as returning `null`.

PostgresSQL treats some numerical operations (such as division by zero) that would compute a `NaN` as a numerical error that causes the query to fail. PostgresQL considers `NaN` to be larger than positive infinity, both in comparison and in sort order. This proposal achieves something very similar by evaluating comparisons involving a `NaN` to `null` and by treating both `NaN` as the largest number and `null` as the largest value in the <<global-sort-order>>.

This proposal could be extended with an operator for making equivalence accessible beyond use in grouping and `DISTINCT`. This seems desirable due to the equality operator (`=`) not being reflexive for all values.

Also noteworthy: If <<unknown-null,unknown `null` values>> would track their source, equality could become reflexive again as it would become possible to know if two `null` values represent the same "unknown" value.

== Benefits to this proposal

A consistent set of rules is defined for <<equality-con,equality>>, <<equivalence-con,equivalence>>, <<comparability-con,comparability>> and <<orderability-con,orderability>>.

== Caveats to this proposal

Adopting this proposal may break some queries; specifically queries that depend on equality semantics of lists containing `null` values.
It should be noted that we expect that most lists used in queries are constructed using `collect()`, which never outputs `null` values.

== Appendix: Comparability by Type

The following table captures which types may be compared with each other such that the outcome is either `true` or `false`.
Any other comparison will always yield `null` (except for `NaN`) which is handled as described above.

.Comparability of values of different types (`X` means the result of comparison will always return `true` or `false`)
[frame="topbot",options="header,footer"]
|================================================================================================================================
|Type           | `NODE` | `RELATIONSHIP` | `PATH` | `MAP` | `LIST OF ANY?` | `STRING` | `BOOLEAN` | `INTEGER` | `FLOAT` | `VOID`
|`NODE`         | X      |                |        |       |                |          |           |           |         |
|`RELATIONSHIP` |        | X              |        |       |                |          |           |           |         |
|`PATH`         |        |                | X      |       |                |          |           |           |         |
|`MAP`          |        |                |        | X     |                |          |           |           |         |
|`LIST OF ANY?` |        |                |        |       | X              |          |           |           |         |
|`STRING`       |        |                |        |       |                | X        |           |           |         |
|`BOOLEAN`      |        |                |        |       |                |          | X         |           |         |
|`INTEGER`      |        |                |        |       |                |          |           | X         | X       |
|`FLOAT`        |        |                |        |       |                |          |           | X         | X       |
|`VOID`         |        |                |        |       |                |          |           |           |         |
|================================================================================================================================
`
